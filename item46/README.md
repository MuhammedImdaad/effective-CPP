### Define non-member functions inside templates when type conversions are desired
Item extends the discussion to Item 24's example. The only difference is that Rational and operator* are now templates. In Item 24, compilers know what function we're trying to call, but here, compilers do not know which function we want to call. Instead, they're trying to figure out what function to instantiate. In order to do the instantiation, they have to figure out what T is. The problem is, they can't. Because implicit type conversion via constructor calls is not considered during template argument deduction. We can relieve compilers of the challenge of template argument deduction by taking advantage of the fact that a friend declaration in a template class can refer to a specific function. 

An interesting observation about this technique is that the use of friendship has nothing to do with a need to access non-public parts of the class. In order to make type conversions possible on all arguments, we need a non-member function, and in order to have the proper function automatically `instantiated`, we need to declare the function inside the class. The only way to declare a non-member function inside a class is to make it a friend. So that's what we do. Unconventional? Yes. Effective? Without a doubt.
#### THINGS TO REMEMBER
* When writing a class template that offers functions related to the template that support implicit type conversions `on all parameters`, define those functions as friends inside the class template.