## Familiarize yourself with perfect forwarding failure cases
C++11’s perfect forwarding is very good, but it achieves true perfection only if you’re willing to overlook an epsilon or two.  
what’s meant by “perfect forwarding.” Perfect forwarding means we don’t just forward objects, we also forward their salient characteristics: their types, whether they’re lvalues or rvalues, and whether they’re const or volatile. That rules out by-value parameters. Pointer parameters are also ruled out. 
```
template<typename T>
void fwd(T&& param)                  // accept any argument
{
  f(std::forward<T>(param));         // forward it to f
} 
```

Several kinds of arguments lead to kind of failures in perfect forwarding. Knowing what they are and how to work around them is important. 
* Braced initializers   
All such failure cases have the same cause. Passing a braced initializer to a function template parameter that’s not declared to be a std::initializer_list is decreed to be, as the Standard puts it, a “non-deduced context.” Compilers are forbidden from deducing a type for the expression in the call to fwd, because fwd’s parameter isn’t declared to be a std::initializer_list. 
* 0 or NULL as null pointers
* Declaration-only integral static const and constexpr data members     
As a general rule, there’s no need to define integral static const and constexpr data members in classes; declarations alone suffice. That’s because compilers perform const propagation on such members’ values, thus eliminating the need to set aside memory for them. If such member's address were to be taken (e.g., if somebody created a pointer), then member would require storage (so that the pointer had something to point to), and the code, though it would compile, would fail at link-time until a definition for member was provided. fwd's parameter is a universal reference, and references, in the code generated by compilers, are usually treated like pointers. In the program’s underlying binary code (and on the hardware), `pointers and references are essentially the same thing`. Passing integral static const and constexpr data members by reference, then, generally requires that they be defined. 
* Overloaded function names and template names  
Usually compilers figure out which version of function is required in a given context. fwd, however, being a function template, doesn’t have any information about what type it needs, and that makes it impossible for compilers to determine which overload should be passed. 
* Bitfields     
In C++, we can define a bit field by specifying the data type and then the field name with the desired width in bits, `dataType fieldName : width;` C++ dictates that the smallest thing you can point to is a char. Therefore, no function can bind a reference to a bitfield, nor can any function accept pointers to bitfields, because pointers to bitfields don’t exist.

In most cases, perfect forwarding works exactly as advertised. You rarely have to think about it. But when it doesn’t work—when reasonable-looking code fails to compile or, worse, compiles, but doesn’t behave the way you anticipate—it’s important to know about perfect forwarding’s imperfections. Equally important is knowing how to work around them. In most cases, this is straightforward. 
### THINGS TO REMEMBER
* Perfect forwarding fails when template type deduction fails or when it deduces the wrong type.
* The kinds of arguments that lead to perfect forwarding failure are braced initializers, null pointers expressed as 0 or NULL, declaration-only integral const static data members, template and overloaded function names, and bitfields.