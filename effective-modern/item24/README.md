## Distinguish universal references from rvalue references
`T&&` is either rvalue reference or lvalue reference. They can bind to virtually anything. Such unprecedentedly flexible references deserve a name of their own; universal references. If you see `T&&` without type deduction (template or auto), you’re looking at an rvalue reference. Because universal references are references, they must be initialized. The initializer for a universal reference determines whether it represents an rvalue reference or an lvalue reference. For a reference to be universal, it must be precisely `T&&`. Even the simple presence of a const qualifier is enough to disqualify a reference from being universal. Bear in mind that this entire item - foundation of universal references - is an abstraction. The underlying truth is known as reference collapsing. 
### THINGS TO REMEMBER
* If a function template parameter has type T&& for a deduced type T, or if an object is declared using auto&&, the parameter or object is a universal reference.
* If the form of the type declaration isn’t precisely type&&, or if type deduction does not occur, type&& denotes an rvalue reference.
* Universal references correspond to rvalue references if they’re initialized with rvalues. They correspond to lvalue references if they’re initialized with lvalues.  