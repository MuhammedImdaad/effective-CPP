## When using the Pimpl Idiom, define special member functions in the implementation file
If you’ve ever had to combat excessive build times, you’re familiar with the Pimpl (“pointer to implementation”) Idiom. That’s the technique whereby you replace the data members of a class with a pointer to an implementation class (or struct), put the data members that used to be in the primary class into the implementation class, and access those data members indirectly through the pointer. The Pimpl Idiom is a way to reduce compilation dependencies between a class’s implementation and the class’s clients, but, conceptually, use of the idiom doesn’t change what the class represents.  
A type that has been declared, but not defined, is known as an incomplete type. Part 1 of the Pimpl Idiom is the declaration of a data member that’s a pointer to an incomplete type. Part 2 is the dynamic allocation and deallocation of the object that holds the data members that used to be in the original class. Applying the Pimpl Idiom in C++98 is mentioned in [Effective C++:Item 31](../effective/item31/README.md).  

For purposes of implementing the Pimpl Idiom, `std::unique_ptr` is the smart pointer to use, because the pImpl pointer inside an object (e.g., inside a Widget) has exclusive ownership of the corresponding implementation object. When std::unique_ptr is used to manage the pImpl resource, a destructor is no longer needed to manage the resouce. However such program failes at compile time! This apparent failure of the Pimpl Idiom using std::unique_ptrs is alarming, because (1) std::unique_ptr is advertised as supporting incomplete types, and (2) the Pimpl Idiom is one of std::unique_ptrs most common use cases.    
When the compiler generates code for the destruction of the Widget, it generally encounters a static_assert that fails, and that’s usually what leads to the error message. This message is associated with the point where w is destroyed, because Widget’s destructor, like all compiler-generated special member functions, is implicitly inline. To fix the problem, you just need to make sure that at the point where the code to destroy the `std::unique_ptr<Widget::Impl>` is generated, Widget::Impl is a complete type. `The type becomes complete when its definition has been seen`, and Widget::Impl is defined inside widget.cpp. The key to successful compilation, then, is to have the compiler see the body of Widget’s destructor (i.e., the place where the compiler will generate code to destroy the std::unique_ptr data member) only inside widget.cpp after Widget::Impl has been defined.    
For std::unique_ptr, the type of the deleter is part of the type of the smart pointer, and this necessitates the pointed-to types must be complete when compiler-generated special functions (e.g., destructors or move operations) are used.
### THINGS TO REMEMBER 
* The Pimpl Idiom decreases build times by reducing compilation dependencies between class clients and class implementations.
* For std::unique_ptr pImpl pointers, declare special member functions in the class header, but implement them in the implementation file. Do this even if the default function implementations are acceptable.
* The above advice applies to std::unique_ptr, but not to std::shared_ptr.